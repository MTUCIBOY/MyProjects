.SECTION/DM vars;

// Числа записаны начиная со старшего разряда, то есть с 47 до 0 бита
.var/circ A[3] = 0x0000, 0x0000, 0x0000; // Первый член умножения
.var/circ B[3] = 0x0000, 0x0000, 0x0000; // Второй член умножения
.var/circ res[3] = 0, 0, 0; // Результат
.var/circ temp[3] = 0, 0, 0; // Временный буфер для хранения 
.var/circ oneBit[3] = 0, 0, 1; // Проверочный бит для умножения
.var/circ twoBit[3] = 0, 0, 1; // Проверочный бит для степени
.var/circ BANK[144]; // Степени банка. Каждая степень через три элемента
.var indexBANK; // Индекс массива БАНК
.var indexTwoBit; // Индекс массива twoBit

.var/circ pol[3] = 0x4000, 0x0000, 0x012F; // Модуль
.var/circ E[3] = 0x0000, 0x0000, 0x0000; // Степень

.SECTION/PM program;

encRSA48Bit: // Начало программы шифрования
	dis ar_sat; // Отключение ограничения по разрядной сетки
	M0 = 1; // Модификатор - шаг, с которым идем по массиву
	M1 = 0; // Модификатор - шаг, с которым идем по массиву
	M2 = -1; // Модификатор - шаг, с которым идем по массиву
	
	call getEKey; // Заполняем ключ E

	call vhod; // Берем число из файла


startDegEF:	
	call bank48Bit; // Заполняем банк
	
	cntr = 48; // Количество итераций
	do for1DegEF until CE; // Начало цикла
		call and48BitTBOE; // Проверяем бит
		if ne call updateA; // Обновляем A
		call lshiftTwoBit; // Двигаем twoBit
		call shiftIndexBANK; // Двигаем индекс банка
	for1DegEF: nop; // Конец цикла	
	breakFor1: nop; // Выходим из цикла
	
	do for2DegEF until CE; // Начало цикла
		call and48BitTBOE; // Проверяем бит
		if ne call prepareMul; // Готовимся к умножению
		if eq call else; // Иначе ...
	for2DegEF: nop; // Конец цикла
	call resetTwoBit; // Восстановление массива twoBit
	
	call vihod;
	
	rts;

else: // Если не надо умножать, то ..
	call lshiftTwoBit; // Двигаем twoBit
	call shiftIndexBANK; // Двигаем индекс банка
	rts;
	
bank48Bit: // Создание банка 48-битного числа
	I0 = A; // Обновляем указатели A
	L0 = length(A); // Обновляем длину A
	I1 = BANK; // Обновляем указатели BANK
	L1 = length(BANK); // Обновляем длину BANK
	call transfer48Bit; // Заполняем первый триплет BANK
	dm(indexBANK) = I1; // Сохранение индекса
	
	cntr = 47; // 47 итераций
	do forBank until ce; // Начало цикла
		call startMulEF; // Умножаем А на B
		
		I0 = res; // Обновляем указатели res
		L0 = length(res); // Обновляем длину res
		I1 = dm(indexBANK); // Достаем из памяти место, где остановились в банке
		L1 = length(BANK); // Обновляем длину BANK
		call transfer48Bit; // Заполняем следующий триплет BANK
		dm(indexBANK) = I1; // Сохранение индекса
		
		I1 = A; // Обновляем указатели A
		L1 = length(A); // Обновляем длину A
		call transfer48Bit; // Обновляем A
		
		I1 = B; // Обновляем указатели B
		L1 = length(B); // Обновляем длину B
		call transfer48Bit; // Обновляем B
		
		call resetOneBit; // Обновляем oneBit для следующего умножения
		call clearRes; // Обнуляем res	
	forBank: nop; // Конец цикла
	
	rts;
	
startMulEF: // Умножение A на B
	call bMul; // Вызов bMul
	
	cntr = 47; // Умножение остальных бит (с учетом fitstMul)
	do for1MulEF until CE;
		call mulAonX; // Умножаем A
		call returnInEF; // Возвращаем А в поле
		call bMul; // Вызов умножения на B
	for1MulEF: nop;
	
	rts;
	
bMul: // Первый этап умножения
	call and48BitBOB; // Вызов битого умножения B и oneBit
	if ne call saveResult; // Если была единица, то сохранить в res
	call lshiftOneBit; // Сдвигаем oneBit
	rts;

and48BitBOB: // Операция and между B и oneBit
	/* Обновляем указатели */
	I0 = B; // Обновляем указатели B
	L0 = length(B); // Обновляем длину B
	I1 = oneBit; // Обновляем указатели oneBit
	L1 = length(oneBit); // Обновляем длину oneBit
	I2 = temp; // Обновляем указатели temp
	L2 = length(temp); // Обновляем длину temp

	/* Выполняем операцию AND */
	AX0 = dm(I0, M0); // Достаем первый элемент массива
	AY0 = dm(I1, M0); // Достаем первый элемент второго массива
	AR = AX0 and AY0; // Выполняем операцию AND над старшими разрядами
	dm(I2, M0) = AR; // Обновляем temp
	
	AX0 = dm(I0, M0); // Достаем первый элемент массива
	AY0 = dm(I1, M0); // Достаем первый элемент второго массива
	AR = AX0 and AY0; // Выполняем операцию AND над средними разрядами
	dm(I2, M0) = AR; // Обновляем temp
	
	AX0 = dm(I0, M0); // Достаем первый элемент массива
	AY0 = dm(I1, M0); // Достаем первый элемент второго массива
	AR = AX0 and AY0; // Выполняем операцию AND над младшие разрядами
	dm(I2, M0) = AR; // Обновляем temp

	/* Проверяем была ли единица */
	AR = 0; // Обнуляем регистр
	AY0 = dm(I2, M0); // Достаем элемент из массива temp
	AR = AR + AY0; // Складываем с результатом
	AY0 = dm(I2, M0); // Достаем элемент из массива temp
	AR = AR + AY0; // Складываем с результатом
	AY0 = dm(I2, M0); // Достаем элемент из массива temp
	AR = AR + AY0; // Складываем с результатом
	
	AF = pass AR; // Обнавляем признак АЛУ
	rts;
	
xor48Bit: // Операция xor между двух 48-битных чисел
	AX0 = dm(I0, M0); // Достаем первый элемент массива
	AY0 = dm(I1, M0); // Достаем первый элемент второго массива
	AR = AX0 xor AY0; // Выполняем операцию XOR над старшими разрядами
	dm(I2, M0) = AR; // Обновляем temp
	
	AX0 = dm(I0, M0); // Достаем первый элемент массива
	AY0 = dm(I1, M0); // Достаем первый элемент второго массива
	AR = AX0 xor AY0; // Выполняем операцию XOR над средними разрядами
	dm(I2, M0) = AR; // Обновляем temp
	
	AX0 = dm(I0, M0); // Достаем первый элемент массива
	AY0 = dm(I1, M0); // Достаем первый элемент второго массива
	AR = AX0 xor AY0; // Выполняем операцию XOR над младшие разрядами
	dm(I2, M0) = AR; // Обновляем temp
	
	rts;
	
mulAonX: // Умножение А на X (сдвигаем влево)
	I0 = A; // Обновляем указатели A
	L0 = length(A); // Обновляем длину A
	call lshift48Bit; // Сдвигаем А
	rts;
	
lshiftOneBit: // Сдвиг OneBit влево
	I0 = oneBit; // Обновляем указатели oneBit
	L0 = length(oneBit); // Обновляем длину oneBit
	call lshift48Bit; // Сдвигаем oneBit
	rts;

lshiftTwoBit: // Сдвиг twoBit влево
	I0 = twoBit; // Обновляем указатели twoBit
	L0 = length(twoBit); // Обновляем длину twoBit
	call lshift48Bit; // Сдвигаем twoBit
	rts;
	
returnInEF: // Возвращение A в поле pol
	I0 = A; // Обновляем указатели A
	L0 = length(A); // Обновляем длину A
	AX0 = dm(I0, M1); // Достаем старший элемент
	AR = tstbit 0xE of AX0; // Проверяем вышел ли за поле А
	/*0xE - номер старшего бита. При изменение модуля, нужно менять и номер старшего бита*/
	if ne call xorAonPol;
	
	rts;

lshift48Bit: // Сдвиг влево 48-битного числа
	SE = 1; // Шаг сдвига
	SR0 = dm(I0, M2); // Пропускаем первый элемент и начинаем с последнего
	
	SR0 = dm(I0, M1); // Достаем младший элемент А, но не двигаем
	SR = lshift SR0 (lo); // Двигаем SR0 относительно SR0
	AY0 = SR1; // Если вылез бит, запоминаем его
	dm(I0, M2) = SR0; // Обновляем A
	
	SR0 = dm(I0, M1); // Достаем средний элемент А, но не двигаем
	SR = lshift SR0 (lo); // Двигаем SR0 относительно SR0
	AR = SR0 + AY0; // Если в прошлом шаге вылез бит, записываем его
	AY0 = SR1; // Если вылез бит, запоминаем его
	dm(I0, M2) = AR; // Обновляем A
	
	SR0 = dm(I0, M1); // Достаем старший элемент А, но не двигаем
	SR = lshift SR0 (lo); // Двигаем SR0 относительно SR0
	AR = SR0 + AY0; // Если в прошлом шаге вылез бит, записываем его
	/*В старшем элементе бит вылезти не может*/
	dm(I0, M2) = AR; // Обновляем A
	
	rts;
	
xorAonPol: // Выполнить xor между A и pol
	I0 = A; // Обновляем указатели A
	L0 = length(A); // Обновляем длину A
	I1 = pol; // Обновляем указатели pol
	L1 = length(pol); // Обновляем длину pol
	I2 = temp; // Обновляем указатели temp
	L2 = length(temp); // Обновляем длину temp	
	call xor48Bit; // Выполняем xor между A и pol	

	I0 = temp; // Обновляем указатели temp
	L0 = length(temp); // Обновляем длину temp	
	I1 = A; // Обновляем указатели A
	L1 = length(A); // Обновляем длину A	
	call transfer48Bit; // Переносим из temp в А
	
	rts;

saveResult: // Сохранение результата из A в res	
	I0 = A; // Обновляем указатели A
	L0 = length(A); // Обновляем длину A
	I1 = res; // Обновляем указатели temp
	L1 = length(res); // Обновляем длину temp
	I2 = temp; // Обновляем указатели res
	L2 = length(temp); // Обновляем длину res
	call xor48Bit; // Выполняем xor между A и res
	
	I0 = temp; // Обновляем указатели res
	L0 = length(temp); // Обновляем длину res
	I1 = res; // Обновляем указатели temp
	L1 = length(res); // Обновляем длину temp
	call transfer48Bit; // Переносим из temp в res
	
	rts;
	
transfer48Bit: // Переместить с одного массивав другой	
	AX0 = dm(I0, M0); 
	dm(I1, M0) = AX0; 
	AX0 = dm(I0, M0); 
	dm(I1, M0) = AX0; 
	AX0 = dm(I0, M0); 
	dm(I1, M0) = AX0;
	
	rts;

resetOneBit: // Вернуть исходный бит в массив oneBit
	I0 = oneBit; // Обновляем указатели oneBit
	L0 = length(oneBit); // Обновляем длину oneBit
	
	AX0 = dm(I0, M0); // Идем к младшему элементу oneBit
	AX0 = dm(I0, M0); // Идем к младшему элементу oneBit
	dm(I0, M0) = 0x0001; // Ставим единицу в младший бит
	
	rts;
	
resetTwoBit: // Вернуть исходный бит в массив twoBit
	I0 = twoBit; // Обновляем указатели twoBit
	L0 = length(twoBit); // Обновляем длину twoBit
	
	AX0 = dm(I0, M0); // Идем к младшему элементу twoBit
	AX0 = dm(I0, M0); // Идем к младшему элементу twoBit
	dm(I0, M0) = 0x0001; // Ставим единицу в младший бит
	
	rts;
	
clearRes: // Отчистка результата для сдедующего умножения
	I0 = res; // Обновляем указатели res
	L0 = length(res); // Обновляем длину res
	
	dm(I0, M0) = 0; // Обнуляем
	dm(I0, M0) = 0; // Обнуляем
	dm(I0, M0) = 0; // Обнуляем
	
	rts;
	
and48BitTBOE: // Операция and между twoBit и E
	/* Обновляем указатели */
	I0 = twoBit; // Обновляем указатели twoBit
	L0 = length(twoBit); // Обновляем длину twoBit
	I1 = E; // Обновляем указатели E
	L1 = length(E); // Обновляем длину E
	I2 = temp; // Обновляем указатели temp
	L2 = length(temp); // Обновляем длину temp

	/* Выполняем операцию AND */
	AX0 = dm(I0, M0); // Достаем первый элемент массива
	AY0 = dm(I1, M0); // Достаем первый элемент второго массива
	AR = AX0 and AY0; // Выполняем операцию AND над старшими разрядами
	dm(I2, M0) = AR; // Обновляем temp
	
	AX0 = dm(I0, M0); // Достаем первый элемент массива
	AY0 = dm(I1, M0); // Достаем первый элемент второго массива
	AR = AX0 and AY0; // Выполняем операцию AND над средними разрядами
	dm(I2, M0) = AR; // Обновляем temp
	
	AX0 = dm(I0, M0); // Достаем первый элемент массива
	AY0 = dm(I1, M0); // Достаем первый элемент второго массива
	AR = AX0 and AY0; // Выполняем операцию AND над младшие разрядами
	dm(I2, M0) = AR; // Обновляем temp

	/* Проверяем была ли единица */
	AR = 0; // Обнуляем регистр
	AY0 = dm(I2, M0); // Достаем элемент из массива temp
	AR = AR + AY0; // Складываем с результатом
	AY0 = dm(I2, M0); // Достаем элемент из массива temp
	AR = AR + AY0; // Складываем с результатом
	AY0 = dm(I2, M0); // Достаем элемент из массива temp
	AR = AR + AY0; // Складываем с результатом
	
	AF = pass AR; // Обнавляем признак АЛУ
	rts;
	
shiftIndexBANK: // Двигаем указатель банка
	I0 = dm(indexBANK); // Достаем указатель банка
	L0 = length(BANK); // Длина банка
	
	AX0 = dm(I0, M0); // Двигаем указатель
	AX0 = dm(I0, M0); // Двигаем указатель
	AX0 = dm(I0, M0); // Двигаем указатель
	
	dm(indexBANK) = I0;
	
	rts;
	
updateA: // Обновляем A
	I0 = dm(indexBANK); // Достаем указатель банка
	L0 = length(BANK); // Длина банка
	I1 = A; // Обнавляем указатель A
	L1 = length(A); // Длина А	
	call transfer48Bit; // Перенос из банка в А
	
	dm(indexBANK) = I0; // Сохраняем индекс
	
	call lshiftTwoBit; // Двигаем twoBit
	jump breakFor1; // Выйти из цикла
	
prepareMul: // Готовим B к умножению на А
	I0 = dm(indexBANK); // Достаем указатель банка
	L0 = length(BANK); // Длина банка
	I1 = B; // Обнавляем указатель B
	L1 = length(B); // Длина B	
	call transfer48Bit; // Перенос из банка в B
	
	dm(indexBANK) = I0; // Сохраняем индекс
	
	call startMulEF; // Умножение А на B
	
	I0 = res; // Достаем указатель res
	L0 = length(res); // Длина res
	I1 = A; // Обнавляем указатель A
	L1 = length(A); // Длина A
	call transfer48Bit; // Перенос из res в A
	
	call resetOneBit; // Обновляем oneBit для следующего умножения
	call clearRes; // Обнуляем res
	call lshiftTwoBit; // Двигаем twoBit
	
	AR = pass 1;
	rts;

vhod: // Взятие из файла данных
	I0 = A; // Обнавляем указатель A
	L0 = length(A); // Длина А
	I1 = B; // Обнавляем указатель B
	L1 = length(B); // Длина B
	
	AX0 = IO(0); // Достаем число из файла
	dm(I0, M0) = AX0; // Кладем число в массив
	dm(I1, M0) = AX0; // Кладем число в массив
	AX0 = IO(0); // Достаем число из файла
	dm(I0, M0) = AX0; // Кладем число в массив
	dm(I1, M0) = AX0; // Кладем число в массив
	AX0 = IO(0); // Достаем число из файла
	dm(I0, M0) = AX0; // Кладем число в массив
	dm(I1, M0) = AX0; // Кладем число в массив
	
	call startDegEF;
	
	rts;
	
vihod: // Запись результата в файла
	I0 = A; // Обнавляем указатель A
	L0 = length(A); // Длина А
	
	AX0 = dm(I0, M0); // Достаем число из массива
	IO(1) = AX0; // Записываем число в файл
	AX0 = dm(I0, M0); // Достаем число из массива
	IO(1) = AX0; // Записываем число в файл
	AX0 = dm(I0, M0); // Достаем число из массива
	IO(1) = AX0; // Записываем число в файл
	
	call vhod;
	
	rts;

getEKey: // Получение ключа E
	I0 = E; // Обновляем указатель E
	L0 = length(E); // Длина Е
	
	AX0 = IO(2); // Достаем часть ключа
	dm(I0, M0) = AX0; // Кладем часть ключа
	AX0 = IO(2); // Достаем часть ключа
	dm(I0, M0) = AX0; // Кладем часть ключа
	AX0 = IO(2); // Достаем часть ключа
	dm(I0, M0) = AX0; // Кладем часть ключа
	
	rts;
